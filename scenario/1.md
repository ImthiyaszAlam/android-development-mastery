

### 1. Tell me about yourself

“I’m Imthiyas, an Android Developer with 13 months of experience at Yolo9 Internet Solutions. I was the only Android developer handling the **Surveykshan app**, where I worked end-to-end on features like offline-first support, FCM notifications, WorkManager, background services, Room DB, AWS integration, and API handling. I enjoy solving production issues, optimizing apps for performance, and designing scalable solutions. Currently, I’m looking to join a product-based company where I can contribute to larger-scale challenges and grow into a stronger Android engineer.”

---

### 2. How do you handle production issues?

* First step: **Identify and reproduce** the issue (logs, crash reports, monitoring tools like Firebase Crashlytics).
* Second: **Prioritize severity** (crash > feature bug > UI issue).
* Third: **Apply hotfix / rollback** if critical, while preparing a long-term solution.
* Fourth: **Add monitoring + unit/UI tests** to prevent recurrence.
  👉 Example: I once debugged a **WorkManager crash** in production by quickly reproducing it with logs, patching with a fallback retry mechanism, then later optimized job constraints.

---

### 3. How will you design a weather app for online and offline, and update offline?

* **Architecture:** MVVM + Repository pattern.
* **Online:** Fetch weather data via API (Retrofit).
* **Offline:** Cache results in **Room DB** with timestamp.
* **Updating offline:** When app opens → check last update time. If expired → fetch new API → update DB → UI observes DB via Flow/LiveData.
* **Edge case:** If no internet → load last cached data + show a “last updated X mins ago” banner.

---

### 4. How would you optimize a large property list?

* Use **RecyclerView/LazyColumn** with ViewHolder pattern.
* **Pagination** (e.g., Paging 3) instead of loading everything.
* Use **DiffUtil** for efficient updates.
* Cache images with **Glide/Coil**.
* Keep item layouts lightweight (ConstraintLayout).

---

### 5. How will you prevent infinite scrolling?

* Add **pagination end condition**:

  * Stop fetching when API says “no more data.”
  * Show “End of list reached.”
* Use Paging 3 (it auto handles no more items).
* Add **scroll threshold checks** to prevent duplicate calls.

---

### 6. What data structure will you use to store leaderboard?

* **Balanced Tree / Heap / PriorityQueue** → for top-N queries.
* In Android, usually:

  * **ArrayList** if only displaying sorted once.
  * **PriorityQueue** if frequent insertions & top-K queries.
    👉 Example: For a real-time game leaderboard, I’d use a **min-heap (PriorityQueue)** to efficiently keep top scores.

---

### 7. Diff between ArrayList and LinkedList and why?

* **ArrayList** → Dynamic array, fast random access (O(1)), slower insert/delete in middle (O(n)).
* **LinkedList** → Doubly linked nodes, fast insert/delete (O(1)), slow random access (O(n)).
  👉 For Android apps, I’d prefer **ArrayList** because we mostly need indexing & iteration (UI lists, API responses).

---

### 8. How would you improve user experience?

* **Smooth UI:** Optimize rendering, avoid overdraw.
* **Fast load times:** Use caching + lazy loading.
* **Offline support** where possible.
* **Meaningful feedback:** Snackbars, progress indicators.
* **Accessibility & Material Design guidelines.**

---

### 9. How will you ensure the app is not laggy and quite simple?

* Move heavy tasks (API, DB, image processing) to **background threads / coroutines**.
* Use **RecyclerView optimizations** (setHasFixedSize, itemView recycling).
* Avoid unnecessary nested layouts.
* Use profiling tools (Android Profiler, LeakCanary) to detect memory leaks.
* Compress images before displaying.

---

### 10. How do you make an API call?

* Use **Retrofit with Coroutines/Flow**.
* Example:

  ```kotlin
  interface WeatherApi {
      @GET("weather")
      suspend fun getWeather(@Query("city") city: String): Response<WeatherResponse>
  }
  ```

  Repository calls API inside coroutine → stores in Room → ViewModel exposes LiveData/Flow → UI observes.

---

### 11. Do you have any questions for me?

(Always ask 1–2 thoughtful ones)

* “What kind of Android challenges does your team face in production?”
* “How does the company support developer growth and mentorship?”

---

### 12. How will you optimize if user uploads a large number of images with larger file size?

* **Before upload:**

  * Compress images (JPEG/WebP).
  * Resize resolution to a reasonable limit.
  * Batch uploads instead of one giant payload.
* **During upload:**

  * Use **WorkManager** with retry + constraints (Wi-Fi only, charging).
  * Use multipart uploads (chunked if very large).
* **After upload:**

  * Cache locally + update server once done.

