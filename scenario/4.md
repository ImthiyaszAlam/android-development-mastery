1. Why Coroutine and not WorkManager, and vice versa?

💬 Answer:

> “Coroutines are best when I need lightweight, immediate, cancellable background work — like network calls, DB queries, or parallel tasks while the app is in foreground. They give fine-grained control over threading.
WorkManager, on the other hand, is for deferrable, guaranteed, and persistent work — like syncing analytics or uploading logs, where the job must run even if the app is killed or device restarts.
So:

If I’m calling an API → Coroutines.

If I’m scheduling a 5 MB file upload at night, even after reboot → WorkManager.
In short: Coroutines = immediate + lifecycle-bound, WorkManager = guaranteed + system-managed.”





---

2. If you have to upload a 20 MB image, how will you implement it?

💬 Answer:

> “For a 20 MB file, direct upload risks timeouts, retries, and memory pressure. I’d use chunked upload strategy — splitting into parts, upload sequentially/parallel, then server reassembles.
I’d wrap this in WorkManager with constraints like WiFi only + charging state. That ensures reliability.
On top, I’d add exponential backoff retries for failures, and show a foreground notification for UX transparency.”




---

3. Most challenging concept you have worked on?

💬 Answer (example for you):

> “Implementing offline-first sync was the most challenging. I had to ensure local DB, remote API, conflict resolution, and background retry all aligned. It wasn’t just about code, but about designing data flow and handling edge cases like partial updates, offline edits, and merges. That taught me how to think beyond coding and into system-level reliability.”




---

4. Most complex UI you have built?

💬 Answer (example):

> “I built a dynamic dashboard with nested RecyclerViews and custom graphs. It required handling pagination, animations, and real-time updates. I optimized it using DiffUtil and ViewPool reuse.
In Compose, I also built a LazyColumn-based feed with multiple item types (image, video, ads, polls). The challenge was not layout itself, but keeping scrolling smooth and memory efficient.”




---

5. How would you implement deep link, and how did you in your last org? What if you have to go to a specific screen?

💬 Answer:

> “Deep links can be handled via:

Manifest intent-filters for external entry (http/https).

App Links / Firebase Dynamic Links for verification.

Navigation Component with NavDeepLinkRequest for in-app routing.
In my last org, we used Firebase Dynamic Links, parsed parameters (like userId=123), then navigated to the exact fragment via NavController.
For going to a specific screen, I’d design my deep link to include route + arguments, so navigation is deterministic.”





---

6. How to get real-time location in an app?

💬 Answer:

> “I’d use FusedLocationProviderClient with requestLocationUpdates inside a foreground service.
To avoid battery drain, I’d:

Use PRIORITY_BALANCED_POWER_ACCURACY.

Request updates at reasonable intervals (e.g., 5–10 sec).

Stop updates when not needed.
If the app needs occasional location, I’d fetch on-demand instead of continuous tracking.”





---

7. How would you design Instagram Home UI?

💬 Answer:

> “It’s essentially a feed of heterogeneous items (image, video, carousel, ads).
In RecyclerView: Use multiple view types + ExoPlayer for videos + ViewPool for nested carousels.
In Compose: Use LazyColumn with itemsIndexed and conditionally render composables.
Optimization:

Use pagination (Paging 3).

Pre-fetch next items.

Offload heavy media loading to Glide/Coil.”





---

8. What is Coroutine?

💬 Answer:

> “Coroutine is a Kotlin concurrency framework that allows writing async code sequentially. Unlike threads, they are lightweight, suspendable, and don’t block.
They run on dispatchers like IO, Default, Main. They integrate with lifecycle, structured concurrency, and provide scopes for automatic cancellation.
In short: Coroutines give the performance of threads without their overhead, and help avoid callback hell.”




---

9. How to ensure battery drainage & connectivity issues while tracking location?

💬 Answer:

> “Battery: I’d optimize interval + priority, use geofences when possible, and stop updates in background unless absolutely required.
Connectivity: I’d cache location updates locally and sync in batches when connected.
I’d also add WorkManager to ensure missed updates are synced later.
That way, the user’s phone doesn’t die, and data integrity is maintained.”




---

10. How to ensure retry in WorkManager?

💬 Answer:

> “WorkManager gives built-in retry with Result.retry().
For controlled retries, I’d use:

BackoffPolicy.EXPONENTIAL to avoid server overload.

Constraints (like network available).
If it still fails after max attempts, I’d mark job as failed but notify user or queue it for later manual retry.
This ensures both reliability and user transparency.”




⚡ Answer: What if Firebase Crashlytics shows no line number or screen name?

💬

> “When Crashlytics shows crashes without line numbers or screen context, it usually means either the ProGuard/R8 obfuscation stripped symbol info, or the crash came from a third-party library / native code where mapping isn’t uploaded.



Here’s how I’d handle it step by step:


---

✅ 1. Check ProGuard/R8 Mapping

Crashlytics needs the mapping file to deobfuscate.

If missing, the stack trace looks like random class names.

Fix: Enable uploadCrashlyticsMappingFileRelease in Gradle so every release uploads mapping automatically.



---

✅ 2. Add Screen / Breadcrumbs for Context

Add custom keys (Crashlytics.setCustomKey("screen", "HomeFragment")).

Add breadcrumbs / logs (Crashlytics.log("User clicked upload")).

This way, even if the line is missing, I know which screen and what action triggered it.



---

✅ 3. Use More Granular Logging

Attach user/session identifiers (no PII).

Add structured logs around risky code paths (network, DB, parsing).

Combine Crashlytics with tools like Firebase Analytics for event correlation.



---

✅ 4. Reproduce Locally

If line is missing, rely on pattern of crashes:

Device type

OS version

Steps before crash


Try to simulate with same device/OS.



---

✅ 5. Third-party / Native Crashes

If crash is from SDK or native code, check:

SDK version → upgrade to latest.

Vendor documentation / GitHub issues.


Add a wrapper with try-catch to isolate it.



---

⚡ Example God-Level Answer in Interview

> “If Crashlytics doesn’t show line numbers or screen names, first I’ll confirm if the ProGuard/R8 mapping file was uploaded — otherwise, it’s unreadable.
Then, I always instrument my app with Crashlytics.setCustomKey() and breadcrumbs to log which screen the user was on and what actions happened before the crash.
Even if the line is missing, this lets me narrow it down to a specific flow.
If it’s from a third-party library, I’ll reproduce locally and isolate by updating or replacing the library.
In short — I don’t just wait for Crashlytics to tell me, I make my own app “crash-debuggable” by design.”

